<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .graph-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
        }
        .controls {
            margin-bottom: 20px;
        }
        .sidebar {
            margin-right: 20px;
            width: 200px;
        }
        svg {
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
<div class="graph-container">
    <div class="sidebar">
        <div class="controls">
            <input type="file" id="file-input" accept=".json">
        </div>
        <div class="filter">
            <input type="text" id="filter-input" placeholder="Filter nodes">
            <ul id="node-list"></ul>
        </div>
    </div>
    <div id="container"></div>
</div>

<script>
    document.getElementById('file-input').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.jsonData = JSON.parse(e.target.result);
                drawGraph(document.jsonData);
                populateNodeList(document.jsonData);
            };
            reader.readAsText(file);
        }
    });

    function drawGraph(data, filterNodes=null) {
        d3.select("#container").selectAll("*").remove();

        const nodes = [];
        const calcNodes = {}
        const ruleNodes = {}
        const links = [];

        const filteredNodes = filterNodes ? filterNodes : null;

        // Prepare nodes and links from JSON data
        data.calculationNodes.forEach(node => {
            if (!filterNodes || filteredNodes.includes(node.calculationName)) {
                nodes.push({
                    id: node.calculationName,
                    name: node.calculationName,
                });
                calcNodes[node.calculationName] = true
            }
        });

        const recursiveAddNodes = () => {
            console.log("New iteration");
            let rulesToAdd = false;
            data.calculationRules.forEach(rule => {
                console.log("Processing ", rule);
                if (calcNodes[rule.belongsToCalculation] === true && !ruleNodes[rule.calcRuleId]) {
                    console.log("Rule OK");
                    rulesToAdd = true;

                    nodes.push({
                        id: rule.calcRuleId,
                        name: `Rule ${rule.calcRuleId}`,
                    });
                    ruleNodes[rule.calcRuleId] = true;
                    links.push({
                        source: rule.calcRuleId,
                        target: rule.belongsToCalculation
                    });
                    console.log(rule.calculationName);
                    console.log(rule);
                    if (rule.calculationName !== null) {
                        console.log("Source OK");
                        nodes.push({
                            id: rule.calculationName,
                            name: rule.calculationName
                        });
                        calcNodes[rule.calculationName] = true;
                        links.push({
                            source: rule.calculationName,
                            target: rule.calcRuleId
                        });
                    }
                }
            });
            return rulesToAdd;
        };

        let bool = false;
        do {
            bool = recursiveAddNodes();
        // console.log("Recursion done");
        // nodes.forEach(node => {
        //     if (!node.id || !node.name) {
        //         console.log("Node issue: ", node);
        //     }
        // });
        // links.forEach(link => {
        //     if (!link.source || !link.target) {
        //         console.log("Link issue: ", link);
        //     }
        // });
        } while (bool);

        // Set the dimensions and margins of the graph
        var margin = {top: 10, right: 30, bottom: 30, left: 40},
            width = 1200 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;

        // Append the svg object to the body of the page
        var svg = d3.select("#container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .call(d3.zoom().on("zoom", function (event) {
                svg.attr("transform", event.transform);
            }))
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // Define arrow markers for links
        svg.append("defs").append("marker")
            .attr("id", "arrowhead")
            .attr("viewBox", "-0 -5 10 10")
            .attr("refX", 13)
            .attr("refY", 0)
            .attr("orient", "auto")
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("xoverflow", "visible")
            .append("svg:path")
            .attr("d", "M 0,-5 L 10 ,0 L 0,5")
            .attr("fill", "#999")
            .style("stroke", "none");

        // Initialize the links
        var link = svg
            .selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .attr("class", "link")
            .attr("stroke", "#999")
            .attr("stroke-width", 2)
            .attr("marker-end", "url(#arrowhead)");
        console.log("Links added");

        // Initialize the nodes
        var node = svg
            .selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .attr("r", 10)
            .style("fill", "#69b3a2")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));
        console.log("Nodes added");

        var text = svg
            .selectAll("text")
            .data(nodes)
            .enter()
            .append("text")
            .attr("dy", -10)
            .text(d => d.name);
        console.log("Text added");

        // Let's list the force we want to apply on the network
        console.log(nodes);
        console.log(links);
        var simulation = d3.forceSimulation(nodes)                 // Force algorithm is applied to data.nodes
            .force("link", d3.forceLink(links)                     // This force provides links between nodes
                .id(function(d) { return d.id; })                  // This provides the id of a node
            )
            .force("charge", d3.forceManyBody().strength(-400))    // This adds repulsion between nodes. Play with the -400 for the repulsion strength
            .force("center", d3.forceCenter(width / 2, height / 2)) // This force attracts nodes to the center of the svg area
            .on("tick", ticked);

        // This function is run at each iteration of the force algorithm, updating the nodes position.
        function ticked() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node
                .attr("cx", function (d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            text
                .attr("x", function (d) { return d.x; })
                .attr("y", function(d) { return d.y; });
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        console.log("Draw finished");
    }

    function populateNodeList(data) {
        const nodeList = document.getElementById('node-list');
        nodeList.innerHTML = '';

        data.calculationNodes.forEach(node => {
            const listItem = document.createElement('li');
            listItem.textContent = node.calculationName;
            nodeList.appendChild(listItem);
        });

        const filterInput = document.getElementById('filter-input');
        filterInput.addEventListener('input', function(event) {
            const filter = event.target.value.toLowerCase();
            const items = nodeList.getElementsByTagName('li');
            const filterNodes = [];
            for (let i = 0; i < items.length; i++) {
                const text = items[i].textContent.toLowerCase();
                if (text.includes(filter)) {
                    items[i].style.display = '';
                    filterNodes.push(items[i].textContent);
                } else {
                    items[i].style.display = 'none';
                }
            }
            console.log(filterNodes);
            drawGraph(document.jsonData, filterNodes);
        });
    }
</script>
</body>
</html>
